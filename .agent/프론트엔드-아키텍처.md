# Pragmatic FSD Architecture

표준 Feature-Sliced Design(FSD)을 실무에 맞게 경량화한 **4-Layer 아키텍처**로, React Router v7 기반 프로젝트에서 **구조적 일관성**, **도메인 격리**, **UI/로직 분리**, **외부 의존성 경계 명확화**를 목표로 합니다.

---

## 1. 목표와 핵심 원칙

### 목표

- React Router v7의 기본 구조를 **Pragmatic FSD 4-Layer**로 정렬하여, 라우팅과 도메인 조립을 명확히 분리합니다.
- 비즈니스 로직은 도메인 단위로 격리하고, UI와 데이터 로직을 분리하여 유지보수성과 확장성을 높입니다.

### 핵심 원칙

- **도메인 중심 설계**: 비즈니스 규칙의 중심을 `domains/<domain>/model`에 둡니다.
- **경계 기반 설계(클린 아키텍처 유사)**: `api`는 외부(서버)와 애플리케이션 내부의 경계로서, DTO 기반 변환을 통해 안전하게 모델을 보호합니다.
- **React 로직 분리**: `application`은 view-model/mutation/store/form 등 UI orchestration을 담당합니다(단, “데이터 조회 훅”은 만들지 않습니다).
- **TanStack Query 표준화**: 데이터 조회는 항상 `queryOptions` 기반 팩토리(`domains/<domain>/<domain>.queries.ts`)를 통해서만 정의/사용합니다.
- **Foundation 분리**: 도메인을 모르는 순수 UI/유틸은 `foundation`에 위치합니다.
- **케밥 케이스 강제**: 모든 디렉토리/파일명은 케밥 케이스로 통일합니다.
- **점 표기법(role suffix) 기반 파일 역할 명시**: 파일 역할을 `name.role.ext`로 표현합니다(예외 포함).

---

## 2. 4-Layer 개요

Pragmatic FSD는 다음 4개 레이어로 구성됩니다.

1. **app**: 앱 전역 설정(Provider, global styles, entry 등)
2. **foundation**: 도메인을 모르는 순수 UI 컴포넌트 및 유틸리티(구 shared)
3. **domains**: 비즈니스 로직의 핵심(주제별 격리: user/product/cart 등)
4. **routes**: 라우팅 주체이자 composition root(구 pages). 여러 도메인을 조립해 화면을 완성

> `routes`는 “페이지 레이어”로서, 도메인 간 결합이 필요할 때 이를 담당하는 **조립 지점**입니다.
>
> TanStack Query는 `foundation/query-client.ts`의 `queryClient`를 단일 인스턴스로 사용하고, `app/providers/query-provider.tsx`에서 `QueryClientProvider`를 주입합니다(필요 시 `React.Suspense`로 suspense query 사용).

---

## 3. Domains 설계(핵심)

각 도메인은 주제별로 분리된 “작은 아키텍처 단위”이며, 내부는 다음 4개 하위 레이어로 구성됩니다.

1. `model` : 순수 타입스크립트 도메인 코어
2. `api` : 외부와의 경계(openapi-fetch, DTO, mapper)
3. `application` : React 기반 orchestration(query/store/form)
4. `ui` : 렌더링(.tsx)만 담당

### 도메인 디렉토리 표준 구조

```txt
domains/
  <domain>/
    index.ts
    README.md
    <domain>.queries.ts

    model/
      <domain>.types.ts
      <domain>.model.ts
      <domain>.constants.ts
      <domain>.policy.ts
      <domain>.errors.ts
      <domain>.events.ts

    api/
      <domain>.endpoints.ts
      <domain>.dto.ts
      <domain>.mapper.ts
      <domain>.api.ts

    application/
      <domain>.actions.ts
      use-<action>-mutation.ts
      use-<domain>-model.ts
      <domain>.store.ts
      <domain>.context.tsx
      <domain>.provider.tsx
      <domain>-form.schema.ts
      use-<domain>-form.ts

    ui/
      <domain>-list.view.tsx
      <domain>-detail.view.tsx
      <domain>-form.form.tsx
      <domain>-card.card.tsx
      <domain>-item.item.tsx
      <domain>-filters.panel.tsx
      <domain>-dialog.dialog.tsx
      <domain>-skeleton.skeleton.tsx
      index.ts
```

---

## 4. Layer별 책임과 규칙

### 4.1 model 레이어 (도메인 코어)

**순수 TypeScript만 존재**하며, 아래 원칙을 강제합니다.

- `.tsx` 금지
- React 코드 금지
- `application`, `api`를 **몰라야 함**(의존 금지)
- 비즈니스 규칙/불변조건/계산 로직의 단일 진실 소스(SSOT)

#### 대표 파일 역할

- `<domain>.types.ts` : 도메인 타입(엔티티/밸류/명령/쿼리 파라미터)
- `<domain>.model.ts` : 상태 전이/계산/핵심 로직
- `<domain>.policy.ts` : 비즈니스 규칙(구매 가능 조건, 수량 제한 등)

> `model`은 “어떤 프레임워크/라이브러리에도 묶이지 않는 핵심”이어야 합니다.

---

### 4.2 api 레이어 (외부 경계)

`api`는 **클린 아키텍처의 boundary**처럼 동작합니다.

- 서버(OpenAPI 스펙)와 애플리케이션 내부 모델 사이의 경계
- **DTO를 통해 안전하게 변환 수행**
- openapi-fetch를 사용한 호출 래퍼 제공
- React 코드 금지(훅 금지)
- 캐싱/리트라이/상태 관리 금지(그건 `application`의 책임)

#### 대표 파일 역할

- `<domain>.dto.ts` : 서버 스키마 기반 DTO 타입(생성 타입 re-export/alias)
- `<domain>.mapper.ts` : DTO ↔ Domain 변환(핵심 보호 장치)
- `<domain>.api.ts` : openapi-fetch 호출 + mapper 적용까지 수행
- `<domain>.endpoints.ts` : 엔드포인트 상수/식별자 관리

> 이 구조는 “서버 스펙 변화가 도메인 모델을 오염시키는 것”을 DTO/mapper로 차단합니다.

---

### 4.3 application 레이어 (React orchestration)

`application`은 **UI로부터 로직을 분리한 React orchestration 레이어**입니다.

- mutation(변경) 로직, view-model, local state/store, form orchestration
- store/context 등 클라이언트 상태 관리(필요 최소)
- react-hook-form + zod 기반 폼 상태/검증 orchestration
- `ui`는 여기의 훅을 호출만 하고, 로직을 소유하지 않습니다.

#### 대표 파일 역할

- `<domain>.actions.ts` : queryFn/mutationFn에서 재사용할 “순수 호출 함수”(imperative, Promise 반환)
- `use-*-mutation.ts` : mutation hook(폼/버튼 액션 등)
- `use-<domain>-model.ts` : 페이지/뷰 모델 훅(검색 파라미터, UI 상태 등)
- `<domain>.store.ts` : client state(필요 시)
- `use-<domain>-form.ts` : RHF + schema 결합 및 제출 orchestration

> 데이터 조회는 `application`에서 훅으로 감싸지 않습니다. `queryOptions` 팩토리를 `domains/<domain>/<domain>.queries.ts`에 두고, UI에서는 `useQuery(...)` 등 기본 훅과 조합해 사용합니다.

---

### 4.4 ui 레이어 (렌더링 전용)

- `.tsx` 렌더링 코드만 존재
- 데이터/상태 로직은 `application`에서 제공하는 훅 호출로 해결
- 폼 UI는 필드 배치/에러 표시 같은 표현 책임만 가짐

#### 대표 파일 역할

- `*.view.tsx` : 화면 단위 view(조립 가능한 덩어리)
- `*.panel.tsx`, `*.section.tsx` : 화면 내부 블록
- `*.card.tsx`, `*.item.tsx` : 반복 UI 구성 요소
- `*.form.tsx` : 폼 UI(로직은 훅 호출)

---

## 5. 데이터/폼 흐름 표준

### 5.1 데이터 가져오기 흐름

1. `api` : openapi-fetch로 호출 → DTO 수신 → mapper로 domain model 변환
2. `model` : 도메인 데이터 구조/규칙/파생 계산 정의
3. `domains/<domain>/<domain>.queries.ts` : `queryKey` 계층 + `queryOptions` 팩토리 정의(단일 진실 소스)
4. `routes` : `clientLoader`에서 `queryClient.prefetchQuery(domainQueries.xxx())`로 캐시 워밍업(데이터 반환 금지)
5. `ui` : `useQuery(domainQueries.xxx())` / `useSuspenseQuery(...)` / `useQueries(...)`로 조회 후 렌더

#### 5.1.1 QueryOptions 팩토리 표준

- **키 전용 항목**: 키 계층 구조용(`all/lists/details` 등)
- **옵션 항목**: `queryOptions({ queryKey, queryFn, staleTime, gcTime, ... })`

예시:

```ts
export const todoQueries = {
  // 키 전용 항목 (키 계층 구조용)
  all: () => ["todos"] as const,
  lists: () => [...todoQueries.all(), "list"] as const,
  details: () => [...todoQueries.all(), "detail"] as const,

  // 실제 queryOptions를 사용한 쿼리 팩토리
  list: (filters: string) =>
    queryOptions({
      queryKey: [...todoQueries.lists(), filters],
      queryFn: () => fetchTodos(filters),
      staleTime: 10_000,
      gcTime: 60_000,
    }),
  detail: (id: number) =>
    queryOptions({
      queryKey: [...todoQueries.details(), id],
      queryFn: () => fetchTodo(id),
      staleTime: 5_000,
    }),
};
```

### 5.2 폼(데이터) 전송 흐름

1. `ui` : 사용자 입력(UI 컴포넌트)
2. `application` : react-hook-form + zod로 유효성/상태 관리 및 submit orchestration
3. `model` : 비즈니스 규칙 최종 확인(policy/guards)
4. `api` : DTO 변환 후 서버 제출

---

## 6. 네이밍 규칙(케밥 케이스 + 점 표기법 + 예외)

### 6.1 기본 규칙

- 모든 파일/디렉토리명은 **케밥 케이스**
- 기본적으로 파일 역할은 **점 표기법**으로 명시:
  - `product.model.ts`, `product.mapper.ts`, `user.policy.ts`

### 6.2 예외 규칙: Hook 파일은 점 표기법 미사용

대표 export 식별자와 파일명이 강하게 대응되는 경우, **hook 파일은 점 표기법을 쓰지 않고 하이픈으로 역할을 표현**합니다.

- `use-toggle-wishlist-mutation.ts` ✅
- `use-user-form.ts` ✅
- `use-<domain>-model.ts` ✅

> `use-*-query` 류의 “데이터 조회 커스텀 훅”은 만들지 않습니다. 조회는 항상 `<domain>.queries.ts`의 `queryOptions`를 `useQuery` 등과 결합합니다.

---

## 7. 도메인 Public API: index.ts

`domains/<domain>/index.ts`는 도메인의 **공식 진입점**입니다.

- Routes는 도메인 내부 경로를 직접 import 하기보다 `domains/<domain>`을 통해 접근합니다.
- 외부 노출은 최소화합니다.
  - 권장: `ui`의 상위 view, `application`의 대표 훅, `model`의 핵심 타입
  - 비권장: `api/*.dto.ts`, `api/*.endpoints.ts` 같은 서버 세부

---

## 8. 요약

Pragmatic FSD는 다음을 동시에 달성합니다.

- **도메인 중심**: 비즈니스 로직은 `model`에 고립(순수 TS)
- **외부 경계 안전성**: `api`가 DTO/mapper로 서버 변화의 충격을 흡수
- **UI/로직 분리**: `application`은 mutation/model/form을 훅으로 캡슐화(조회는 `<domain>.queries.ts`로 표준화)
- **조립 지점 명확화**: `routes`가 composition root로 도메인을 조립
- **일관된 네이밍**: 케밥 케이스 + 역할 점 표기법(단, hook 파일 예외)

---

원하시면 이 문서를 기준으로 **실제 React Router v7의 route module( loader/action )을 어느 레이어에 배치할지**에 대한 “결정 트리(Decision Tree)” 형태의 규칙까지 포함해, 라우팅과 도메인 경계를 더 단단하게 만드는 확장 버전도 작성해 드리겠습니다.
