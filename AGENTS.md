# 학습 로드맵 서비스

## 1. 프로젝트 개요 (Project Overview)

### 1.1. 문제 정의 및 해결 방안

**핵심 문제**

- **학습 경로의 부재**: 수많은 기술과 지식 속에서 개발자들이 다음에 무엇을 배워야 할지 방향을 잡기 어렵습니다.

  **자기 진단의 어려움**: 스스로 "무엇을 모르는지" 정의하기 어렵고, 체계적인 학습 목표를 지속적으로 관리할 도구가 부족합니다.

  **학습 기록의 파편화**: 블로그, 북마크 등 여러 곳에 흩어진 학습 기록 때문에 성과를 추적하고 관리하기 힘듭니다.

  **정적인 로드맵의 한계**: 기존 로드맵 서비스는 개인의 학습 수준이나 진행 상황을 반영하지 못하는 정적인 정보를 제공합니다.

**해결 방안**

- **개인화된 동적 로드맵**: 사용자의 학습 수준과 목표에 맞춰 AI가 맞춤형 로드맵을 동적으로 생성하고 제안합니다.

  **체계적인 목표 관리**: 칸반 보드, 리스트 뷰 등 다양한 방식으로 학습 목표를 시각화하고 지속적으로 추적할 수 있도록 지원합니다.

  **통합된 학습 히스토리**: 사용자가 완료한 학습 항목을 타임라인과 리포트 형태로 제공하여 성취도를 한눈에 파악할 수 있게 합니다.

### 1.2. 타겟 사용자 및 페르소나

- **주요 타겟**: 학습 방향 설정에 어려움을 겪는 신입 및 주니어 개발자, 새로운 커리어로 전환을 준비하는 사람.

  **부차 타겟**: 새로운 기술 스택을 빠르고 체계적으로 학습하고자 하는 시니어 개발자.

---

## 2. 아키텍처 설계 (Architecture Design)

### 2.1. 기술 스택

**백엔드(apps/api)**

- **런타임**: Node.js
- **프레임워크**: Hono.js
- **ORM**: Drizzle ORM
- **데이터베이스**: Neon DB
- **인증**: 데이터베이스 기반 쿠키 세션 방식
- **AI**: Vercel AI SDK, Google Gemini

**프론트엔드(apps/web)**

- **TanStack Router**: SPA, Type-Safe
- **React 19**: 최신 React
- **TypeScript 5**: 타입 안전성 확보
- **React Aria Components, React Aria, React Stately**: 접근성 기반 컴포넌트 라이브러리
  - 미리 만들어진 컴포넌트(React Aria Components)를 우선 사용하는 고려
  - 부족한 경우 React Aria, Stately를 사용하여 직접 컴포넌트 구축
- **Tailwind CSS**: 유틸리티 퍼스트 스타일링
- **TanStack Query**: 서버 상태 관리
- **Zustand**: 클라이언트 상태 관리
- **React Hook Form + Zod**: 폼 처리 및 검증
- **서버 상태 관리**: TanStack Query로 서버 데이터 캐싱 및 동기화
- **클라이언트 상태 관리**: Zustand로 UI 상태 및 사용자 설정 관리
- **폼 상태 관리**: 가벼운 폼은 React Aria Form 컴포넌트 사용, 복잡한 폼은 React Hook Form으로 폼 검증 및 제출

### 2.2. 데이터베이스 설계

데이터베이스 구조는 [Drizzle ORM 스키마](packages\api\src\database\schema.ts)를 참고

### 2.3. API 아키텍처

- **Type-safe RPC**: Hono 백엔드에서 `AppType`을 export하여 클라이언트에서 타입 안전성을 보장합니다.
- **구조화된 응답**: 모든 API 엔드포인트는 Zod를 활용한 타입 스키마를 사용하여 응답 형식을 통일합니다.
- **인증**: Better Auth 미들웨어를 통해 모든 라우트의 접근을 제어합니다.
- **AI 통합**: Vercel AI SDK(Gemini API)를 사용하여 AI 채팅 및 로드맵 생성 기능을 구현합니다.

---

## 3. 소프트웨어 설계 철학

**일반 원칙**

다음의 일반원칙들을 따라야 합니다.

- 단순성(Simplicity): 기능을 구현하는 가장 단순한 방법을 선택하세요.
- 가독성(Readability): 과도한 추상화를 피하고, 미래의 독자가 쉽게 이해할 수 있는 코드를 작성하세요.
- 의도 드러내기(Intention-Revealing): 코드가 "무엇"을 하는지 명확히 표현하세요.
- 짧은 함수(Small Functions): 함수는 한 가지 일만 하고 길이는 짧게 유지하세요.
- 짧은 클래스(Small Classes): 클래스는 응집도 높고 한 가지 책임만 가지게 만드세요.
- SRP(단일 책임 원칙): 한 모듈/함수/클래스는 오직 하나의 변경 이유만 가져야 합니다.
- OCP(개방-폐쇄 원칙): 기능은 확장 가능하되 기존 코드를 수정하지 않고 확장하세요.
- LSP(리스코프 치환 원칙): 하위 타입은 상위 타입을 대체할 수 있어야 합니다.
- ISP(인터페이스 분리 원칙): 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 합니다.
- DIP(의존성 역전 원칙): 고수준 모듈은 저수준 모듈 구현이 아니라 추상화에 의존해야 합니다.
- DRY(Don’t Repeat Yourself): 중복을 제거해 유지보수 비용을 줄이세요.
- YAGNI(You Aren’t Gonna Need It): 필요하지 않은 기능은 미리 만들지 마세요.
- KISS(Keep It Simple, Stupid): 설계를 단순하고 직관적으로 유지하세요.
- 리팩토링 습관화: 기능 추가 후 반드시 코드 품질을 개선하세요.
- 의존성 최소화: 모듈 간 결합도를 낮추고, 인터페이스를 통해 느슨한 결합을 유지하세요.
- 응집도 높이기: 관련 기능과 데이터는 함께 모아 높은 응집도를 유지하세요.
- 데이터 흐름 가시화: 입력 → 처리 → 출력의 흐름이 한눈에 보이도록 설계하세요.
- 확장 지향 설계: 새 요구사항을 추가할 때 최소한의 코드 변경으로 대응할 수 있게 만드세요.
- 자기 설명적인 코드(Self-describing Code): 의미 있는 변수 이름, 함수 이름, 함수 인자, 반환 값을 사용하세요.
- 일관성: 코드 구조와 형식의 일관성을 유지하세요.‍
- 모듈화: 코드를 모듈화하고 "반복하지 마세요(DRY)" 원칙을 고수하세요.‍
- 강력한 타입 시스템: 유형 안전성과 더 나은 DX를 위해 TypeScript의 고급 기능을 활용하세요
- 변경 불가능한 객체: 변수 및 함수가 생성된 후 변경되지 않도록 하여 예기치 않은 부작용을 방지합니다. 항상 `const`를 사용하세요.
- 함수형 프로그래밍: 함수의 입력-출력 외부에서 상태를 변경하지 않도록 하세요.
- 선언적 프로그래밍: 가능한 선언적 프로그래밍을 사용하여 코드의 의도를 명확하게 표현하세요.
- 예방적 프로그래밍: 문제의 발생을 미리 차단하여, 애초에 오류가 생길 여지를 없앰으로서 매끄러운 사용자 경험을 제공하세요.
- 방어적 프로그래밍: 모든 사용자 입력을 불신하고, 데이터의 유효성을 보장하기 위해 `zod`, `try-catch`문, `ErrorBoundary`등을 활용하여 런타임 검증을 수행하고 예상치 못한 입력이나 잠재적인 오류 상황에서도 소프트웨어가 안정적으로 기능하도록 설계하세요.
- 문제 도메인 우선: 기술보다 비즈니스/도메인 요구사항을 먼저 이해하세요.
- 의식적인 리스크 관리: 불확실성이 클수록 설계를 단순하게, 배포 가능한 상태로 만들고 점진적으로 개선하세요.
- 코드 스멜 감지: 중복, 거대한 클래스, 긴 파라미터 목록 등을 주기적으로 점검하세요.
- 엔트로피 제어: 시간이 지날수록 무질서도가 증가하지 않도록 지속적으로 정리하세요.
- `any` 타입 금지: `any` 타입을 사용하지 마세요. 적절한 타입이 추론된다면 그대로 사용하거나 명시적으로 타입을 지정하세요.

---

## 4. 프로젝트 구조

### 4.1. 리포지토리 구조

- **`apps/web`**: **Vite**와 **Tanstack Router**로 구성된 프론트엔드
  - **`src/domains`**: 기능
  - **`src/routes`**: 라우트
  - **`src/components`**: 컴포넌트
  - **`src/api`**: 생성된 API 클라이언트
- **`apps/api`**: **Hono** 서비스
  - **`src/modules/*`**: 핸들러
  - **`src/middleware`**: 미들웨어
  - **`src/config`**: 설정
  - **`src/database`**: Drizzle 스키마
- **`apps/storybook`**: **`@repo/ui`**를 위한 컴포넌트 작업 공간이며, **`storybook-static`**으로 출력됩니다.
- **`packages/*`**: **`ui`**는 재사용 가능한 **React UI**를 노출하며, **`eslint-config`**, **`prettier-config`**, **`typescript-config`**는 공유 툴링을 제공합니다.

### 4.2. 빌드, 테스트 및 개발 명령어

- **`pnpm install`**: 리포지토리 복제(clone) 후 또는 `lockfile` 변경 후 의존성을 동기화합니다.
- **`pnpm dev`**: 모든 개발 타겟을 실행합니다; **`pnpm --filter web dev`**, **`pnpm --filter api dev`**, 또는 **`pnpm --filter storybook dev`**를 사용하여 범위를 좁힐 수 있습니다.
- **`pnpm build`**: 모든 **`build`** 작업을 트리거합니다; 라이브러리 업데이트가 적용될 때 **`pnpm --filter @repo/ui build`**를 사용하세요.
- **`pnpm lint`**, **`pnpm lint:fix`**, **`pnpm check-types`**, **`pnpm format`**: 린팅, 타입 안정성, 포맷팅을 관리합니다.
- **Drizzle** 명령어 (**`db:push`**, **`db:migrate`**, **`db:seed`**)는 **`DATABASE_URL`**을 설정한 상태로 **`pnpm --filter api ...`**를 통해 실행됩니다.

### 4.3. 코딩 스타일 및 명명 규칙

- **Prettier**는 2칸 들여쓰기, 80자 줄 제한, 후행 쉼표(trailing commas), JSX 속성 한 줄당 하나를 강제합니다.
- **ESLint**는 정렬된 import, 타입 전용 import 일관성, 미사용 식별자 차단을 요구합니다; 커밋하기 전에 새 파일은 깨끗하게 유지하세요.
- 타입 매개변수는 **`T`** 접두사를 붙인 **PascalCase**를 따릅니다; 훅은 **`use`**로 시작합니다; 모듈은 해당 **도메인 폴더** 내에 위치시킵니다 (colocate).

### 4.4. 개발 지침

- `packages/database/migrations` 디렉토리를 직접 수정하지 마세요.
- `pnpm --filter api db:generate` 명령어를 사용하여 마이그레이션 파일을 생성하고, `pnpm --filter api db:push` 명령어를 사용하여 데이터베이스를 업데이트하세요.

- API 스펙을 변경한 후: **`pnpm --filter api dev`**를 실행하고, **`pnpm --filter web schema:generate`**를 실행하여 API 스펙 타입을 업데이트하세요.

### 4.5. 테스트 지침

- **Vitest**와 **Testing Library**가 웹 앱을 지원합니다; 컴포넌트 옆 또는 **`__tests__`** 아래에 **`\*.test.tsx`** 파일을 추가하세요.
- **`pnpm --filter web test`**로 테스트 스위트를 실행합니다; 병합 전 검사를 위해 **`-- --coverage`**를 추가하세요.
- 각 **`@repo/ui`** 추가 사항에는 시각적으로 검증할 수 있도록 **Storybook 스토리**를 쌍으로 추가하세요.
- **Resend**, **Neon**, 또는 **S3** 클라이언트를 스텁(stub)해야 할 때 **`apps/api/src/modules/\**/__tests__`** 아래에 **Hono 라우트 통합 테스트**를 추가하세요.

### 4.6. 커밋 및 Pull Request (PR) 지침

- **Conventional Commits** (`feat:`, `fix:`, `chore:`)를 **`feat: 문서 업로드 ...`**와 같이 사용하고, 제목은 명령형으로 간결하게 유지합니다.
- PR은 **범위**를 명시하고, **이슈**를 연결하며, 영향을 받는 **앱**을 언급해야 합니다; UI 작업의 경우 **스크린샷**이나 **Storybook URL**을 첨부하고, **API 문서 변경 사항**을 언급해야 합니다.
- **린트**, **타입 체크**, **테스트**, 필수 **`db:\*`** 명령을 **요청 전에** 확인하세요.

### 4.7. 환경 및 구성

- **`.env.local`\*\*에 비밀 정보를 보관합니다; 필수 키에는 \*\*`DATABASE_URL`\*\*, \*\*`RESEND_API_KEY`\*\*, \*\*OAuth ID\*\*, 그리고 스토리지 자격 증명 (\*\*`R2_\*`** 또는 **`AWS_\*`**)이 포함됩니다.
- **Drizzle 스키마**를 변경한 후에는 **`pnpm --filter api db:generate`**를 실행한 다음 관련 마이그레이션 명령을 실행합니다.
- 컴포넌트나 스타일이 변경될 때마다 **`pnpm --filter @repo/ui build`**를 사용하여 공유 UI를 **재빌드**해야 웹과 Storybook이 일치하게 유지됩니다.

### 4.8. 문서화

지속적으로 문서화를 진행하세요.

- 도메인 언어 사용(docs/ubiquitous-language.md): 팀이 공통으로 이해하는 용어는 ``에 문서화하세요.
- 트레이드오프 명시(docs/trade-off.md): 성능, 확장성, 유지보수성 등에서 어떤 선택을 했는지 트레이드오프를 문서화하고 나중에 갚을 계획을 세우세요.
