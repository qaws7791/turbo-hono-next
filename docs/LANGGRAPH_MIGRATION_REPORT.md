# LangGraph 기반 에이전트 전환 검토 보고서

## 1. 개요
본 보고서는 현재 시스템의 AI 기능을 LangGraph 기반의 에이전트 아키텍처로 전환하기 위한 타당성 검토, 비용/효과 분석 및 구체적인 구현 계획을 기술합니다.
단순한 요청-응답(Request-Response) 패턴을 넘어, 에이전트가 스스로 판단(Reasoning), 도구 사용(Tool Use), 자기 성찰(Reflection)을 수행하여 생성물의 품질을 획기적으로 높이는 것을 목표로 합니다.

## 2. AI 사용 기능 식별
현재 코드베이스에서 식별된 주요 AI 기능은 다음과 같습니다.

### 2.1 학습 계획 생성기 (`LearningPlanGenerator`)
- **위치**: `apps/api/src/ai/plan/generator.ts`
- **현황**: 2단계 선형 프로세스 (구조 설계 -> 모듈별 세션 생성)
- **문제점**:
    - 한 번 생성된 구조를 검증하거나 수정하는 단계가 없음.
    - 복잡한 요구사항이 있을 경우 구조 설계 단계에서 누락이 발생할 수 있음.

### 2.2 세션 블루프린트 생성기 (`SessionBlueprintGenerator`)
- **위치**: `apps/api/src/ai/session/generator.ts`
- **현황**: 단일 프롬프트로 교육 콘텐츠와 퀴즈를 동시에 생성.
- **문제점**:
    - **할루시네이션 위험**: 생성된 콘텐츠와 퀴즈의 내용이 일치하지 않을 수 있음 (콘텐츠에 없는 내용을 퀴즈로 출제 등).
    - **복잡성**: 하나의 프롬프트에 너무 많은 지시사항(콘텐츠 작성, 포맷팅, 퀴즈 출제 등)이 포함되어 있어 제어가 어려움.

### 2.3 자료 분석기 (`MaterialAnalyzer`)
- **위치**: `apps/api/src/ai/material/analyze.ts`
- **현황**: 단일 패스로 요약 및 목차 추출.
- **문제점**:
    - 긴 문서의 경우 컨텍스트 윈도우 제한이나 정보 손실 발생 가능.
    - 결과물의 일관성 검증 부재.

### 2.4 RAG (검색 증강 생성) 시스템 (`apps/api/src/ai/rag/*`)
- **현황**: 정적인 헬퍼 함수 형태로 존재.
- **전환 방향**: 에이전트가 필요시 스스로 호출할 수 있는 **Tool** 형태로 전환.

---

## 3. 비용 및 효과 예측

### 3.1 효과 (Benefits)
1.  **품질 향상 (High Quality)**
    - **자기 성찰(Self-Correction)**: 에이전트가 생성물을 검토(Review)하고 수정하는 루프를 통해 완성도를 높임.
    - **일관성 보장**: 세션 생성 시, '콘텐츠 생성' -> '검토' -> '퀴즈 생성'의 순차적 흐름을 강제하여 퀴즈가 콘텐츠에 기반하도록 보장.
2.  **확장성 및 유지보수성**
    - 복잡한 프롬프트를 작은 단위의 노드(Node)로 분리하여 관리가 용이함.
    - 새로운 기능(예: 인터넷 검색, 외부 API 연동) 추가 시 도구(Tool)만 추가하면 됨.
3.  **에이전틱 경험 (Agentic UX)**
    - 에이전트가 "자료가 부족하여 추가 검색을 수행합니다"와 같은 중간 사고 과정을 사용자에게 보여줄 수 있음 (스트리밍 시).

### 3.2 비용 (Costs)
1.  **응답 시간 (Latency) 증가**
    - 단일 호출이 아닌 다중 단계(Multi-step) 및 반복 루프(Loop)를 거치므로 최종 응답까지 시간이 길어질 수 있음.
    - **대안**: UI에서 진행 상황(Step)을 시각화하여 체감 대기 시간을 줄여야 함.
2.  **토큰 비용 증가**
    - 사고 과정(Thought Process)과 검토 단계 추가로 인해 LLM 토큰 사용량이 증가함.
    - **대안**: Gemini Flash 등 성능 대비 비용 효율이 높은 모델을 주 모델로 사용.
3.  **구현 복잡도**
    - 상태(State) 관리 및 그래프 흐름 제어 로직이 추가되어 초기 개발 난이도가 상승함.

---

## 4. 구현을 위한 구체적 계획

### 4.1 공통 아키텍처 전략
- **프레임워크**: LangGraph (JS/TS)
- **모델**: Google Gemini (사용자 선호도 반영, 긴 컨텍스트 및 멀티모달 강점 활용)
- **Tooling**: 기존 RAG 로직을 `SearchTool`로 캡슐화하여 에이전트에 주입.

### 4.2 기능별 전환 상세 계획

#### A. 학습 계획 생성 에이전트 (PlanAgent)
**Graph 구조**: `Planning` -> `Review` -> `Refinement` -> `Expansion`
1.  **Analyzer Node**: 사용자 요구사항과 자료의 특성을 분석.
2.  **Architect Node**: 전체적인 커리큘럼 구조(목차)를 설계.
3.  **Critic Node (신규)**: 설계된 구조가 목표 기한/난이도/사용자 요구사항에 맞는지 평가. 미흡하면 피드백과 함께 Architect로 반려.
4.  **Module Expander (Parallel)**: 확정된 구조의 각 모듈을 병렬로 상세화 (Map-Reduce 패턴).

#### B. 세션 생성 에이전트 (SessionAgent)
**Graph 구조**: `ContentDraft` -> `ContentReview` -> `QuizGen` -> `Finalize`
1.  **Writer Node**: RAG 도구를 사용하여 학습 자료(Chunk)를 조회하고, 핵심 교육 콘텐츠(Learn Content)를 작성.
2.  **Reviewer Node**: 작성된 콘텐츠가 "독립적으로 이해 가능한지", "설명이 충분한지" 검사. 부족하면 Writer에게 수정 요청.
3.  **QuizGenerator Node**: **검증된 콘텐츠만을 입력으로 받아** 퀴즈와 액티비티를 생성. (할루시네이션 원천 차단)
4.  **Formatter Node**: 최종 JSON 스키마에 맞춰 결과물 조립.

#### C. 자료 분석 에이전트 (AnalysisAgent)
**Graph 구조**: `Chunking` -> `Extraction` -> `Synthesis`
1.  **Map Node**: 긴 문서를 의미 단위로 분할하고 각각 요약/키워드 추출.
2.  **Reduce Node**: 분할된 정보를 종합하여 전체 요약문과 계층적 목차(Tree) 생성.

### 4.3 마이그레이션 단계 (Phased Approach)

1.  **Phase 1: 인프라 구축**
    - LangGraph 의존성 추가 및 기본 `State` 스키마 정의.
    - Gemini 연동 및 RAG 기능을 `DynamicStructuredTool`로 래핑.

2.  **Phase 2: 세션 생성기 전환 (SessionAgent)**
    - 가장 품질 이슈(할루시네이션)가 우려되는 세션 생성기부터 전환.
    - 콘텐츠-퀴즈 분리 로직 구현.

3.  **Phase 3: 학습 계획 생성기 전환 (PlanAgent)**
    - 복잡한 판단이 필요한 계획 생성 로직 전환.
    - Critic 노드 도입으로 맞춤형 계획 품질 향상.

4.  **Phase 4: 전체 통합 및 최적화**
    - 자료 분석기 전환.
    - LangSmith 등을 활용한 트레이스 모니터링 및 프롬프트 최적화.

## 5. 결론
LangGraph 도입은 단순한 리팩토링이 아니라, 애플리케이션을 **"생성형 도구"에서 "지능형 파트너"로 진화**시키는 과정입니다.
초기 구현 비용과 약간의 레이턴시 증가는 발생하지만, 결과물의 신뢰성과 교육적 가치를 고려할 때 전환의 이점이 훨씬 큽니다.
특히 사용자가 선호하는 **Gemini** 모델은 긴 컨텍스트 처리에 강점이 있어, 교육 자료 분석 및 생성 파이프라인에 최적의 성능을 보일 것으로 예상됩니다.
